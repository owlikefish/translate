ECMAScript语言类型对应被使用ECMAScript语言的ECMAScript程序直接操作的值。ECMAScript语言类型有undefined，null，boolean，string，symbol，number和object。一个ECMAScript语言值是被一个ECMAScript语言类型特征化的值。

# undefined类型
只有一个叫undefined的值。任何没有被赋值的变量都有值undefined

# null类型
只有一个值叫null

# boolean类型
表示一个逻辑实体，有两个值：true和false

# string类型
string类型是0个或多个16-bit无符号整数值（元素）的有序序列的集合，最多达到到2^53-1个元素。string类型通常用来表示一个运行中的ECMAScript程序中的文本数据，这中情况下，string中的每个元素被作为一个UTF-16代码单元值。每个元素被认为占用了序列中的一个位置。位置用一个非负整数索引。第一个元素从index 0开始，下一个是index1，依此类推。string的长度就是其中元素的数量。空字符串的长度为0，因此不包含元素。

在ECMAScript运算符翻译string值的地方，每个元素被翻译成一个单独的UTF-16代码单元。然而，ECMAScript不会在字符串值的代码单元序列上放置任何限制或需求。所以，当把他们翻译成UTF-16代码单元序列的时候，他们可能是病态的。不翻译string内容的运算符会把他们看作未分化的16-bit无符号整数的序列。String.prototype.normalize可被用来明确地标准化字符串值。String.prototype.localeCompare内部地标准化字符串值，但没有其他操作符可以暗含地标准化他们操作的字符串。只有明确指定对语言或规模敏感的操作符会产生语言敏感的结果。

注：设计背后的理念是为了保持字符串的实现尽可能简单和高性能。如果ECMAScript源文本用的是标准化形式C，字符串字面量被确保也要标准化，只要他们不包含任何Unicode跳脱序列。

# 符号类型
符号类型是所有会被用作对象属性键的非字符串值的集合

每个可能的符号值是唯一的并且是不可变的

每个符号值不可变地拥有一个被称作[[Description]]的相关值，它或者是undefined或者是一个字符串。

# 知名符号
知名符号是明确被此规范中的算法引用的内建符号值。

# 数值类型
数值类型正好有18437736874454810627（也就是，2^64-2^53+3）个值，表示在IEEE标准中为二进制浮点算术而指定的双精度64-bit格式IEEE 754-2008值，除了IEEE标准中的9007199254740990（也就是，2^53-2)区分了“Not-a-Number”值在ECMAScript中表示一个特殊的NaN值。（注意NaN值是由程序表达式NaN生成）在一些实现中，额外的代码可能有能力检测到各种Not-a-Number值的不同，但是这样一个行为是依赖实现的；对ECMAScript代码来说，所有的NaN值互相间不可区分。

注：在一个数值值被存放到ArrayBuffer中后可以从ArrayBuffer中得到的位模型没有必要和被ECMAScript实现使用的数字值的内部表示一致。

其它18437736874454810624 (也就是, 2^64−25^3)个值被称为有限值。一半是正值，一半是负值。对于每一个有限的数字值都有一个和它大小相同与之对应的负值。

注意到既有一个正0值，又有一个负0值。为简短起见，这些值也各自被符号+0和-0为了说明的用途而提到，（注意两个不同的零值由表达式+0（或简写0）和-0分别生成）

18437736874454810622（也就是，2^64-2^53-2）个有限非零值有两类：

其中18428729675200069632（也就是，2^64-2^54）个是标准化的，有如下形式： s×m×2^e

s是+1或-1，m是小于2的53次方，但不小于2的52次方的正整数，e是从-1074到971的整数，包括两端。

剩下的9007199254740990（也就是，2^53-2）个是非标准化的，有如下形式：s×m×2^e

s是+1或-1，m是小于2的52次方的整数，并且e是-1074

注意所有的大小不超过2^53的正整数和负整数都可表示成数值类型。（确实，整数0有两种表示，+0和-0）