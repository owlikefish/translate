尽管ECMAScript包含类定义的句法，ECMAScript对象并不是像C++，Smalltalk，或Java这些语言根基上是基于类的。取而代之，对象可以以各种方式创建，这些方式包括通过字面记法，或者通过构造器。构造器会创建对象，然后执行代码，通过给它们的属性赋予初始值，来初始化它们中的所有或一部分。每个构造器都是一个具有prototype属性的函数。prototype用来实现基于原型的继承和共享属性。对象通过在new表达式中使用构造器来生成；比如说，new Date(2009,11)创建了一个新的日期对象。不使用new来调用一个构造器会得到取决于构造器的结果。比如，Date()会生成一个表示当前日期和时间的字符串而不是对象。

每个由构造器创建的对象会暗含一个指向构造器原型属性的引用，它被叫做对象的原型。更进一步，一个原型可能有一个指向该原型的原型的非空暗含引用，依次类推；这就叫做原型链。当一个引用成为一个对象中的属性，该引用指向包含该名称属性的原型链中第一个对象中具有该名称的属性。换句话说，首先在直接提到的对象中检查这样一个属性；如果该对象包含该名称的属性，那就是该引用提到的属性，如果该对象不包含该名称的属性，接下来就检查该对象的原型，依次类推。

Figure 1 —— Object/Prototype Relationships

在一个基于类的面向对象的语言中，通常，实例携带状态，类携带方法，只有结构和行为可以被继承。在ECMAScript中，对象携带状态和方法，同时，结构，行为和状态都可以被继承。

所有的对象都不会直接包含一个特殊属性（他们的原型所包含共享的属性和值）。对图例1的解释如下：

CF是一个构造器（也是一个对象）。使用new表达式构造5个对象：cf1，cf2，cf3，cf4和cf5。每个对象包含属性q1和q2。短划线表示暗含的属性关系；所以，比如说cf3的原型是CFp。构造函数CF，有两个自有属性，P1和P2，它们对CFp，cf1，cf2，cf3，cf4，cf5均不可见。在CFp中名叫CFP1的属性被cf1，cf2，cf3，cf4和cf5（但不被CF）共享，任何在CFp的暗含原型链中找到的属性都不叫q1，q2，或CFP1。注意到在CF和CFp中没有暗含原型链。

不像大多数基于类的对象语言，属性可以通过赋值动态地添加到对象中。那是说，构造函数不需要对任何被构造的对象中的属性进行命名和赋值。在上面的图表中，可以通过给CFp中的新属性赋值来为cf1，cf2，cf3，cf4和cf5增加一个共享的属性。

尽管ECMAScript本质上不是基于类的，但它常常很方便地就能根据一个普通的构造函数、原型对象和方法的模型来定义类似类的抽象。ECMAScript内建对象本身也是遵循了这样一个类似类的模型。从ECMAScript 2015开始，ECMAScript语言包含了句法类定义，它使得程序能够根据和被内建的对象使用的同样的类似类的抽象模型来简明地定义对象。